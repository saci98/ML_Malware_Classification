import os.path
import re
from typing import Tuple, Callable, Sequence
import numpy as np
import pandas as pd
from sklearn.feature_extraction.text import CountVectorizer
from scipy.sparse import csr_matrix
from Utils.ReadFile import ReadFile
from math import log

SeqReader = Callable[[str], str]

opcodes = ['add', 'align', 'and', 'bt', 'call', 'cdq', 'cld', 'cli', 'cmc', 'cmp', 'cwd', 'daa', 'db', 'dd', 'dec',
           'dw', 'faddp', 'fchs', 'fdiv', 'fdivp', 'fdivr', 'fild', 'fistp', 'fld', 'fstcw', 'fstcwimul', 'fstp',
           'fword', 'fxch', 'imul', 'inc', 'ins', 'ja', 'jb', 'jbe', 'je', 'jg', 'jge', 'jl', 'jle', 'jmp', 'jnb',
           'jno', 'jnz', 'jo', 'jz', 'lea', 'loope', 'mov', 'movsw', 'movzx', 'mul', 'neg', 'not', 'or', 'out', 'outs',
           'pop', 'popf', 'push', 'pusha', 'pushf', 'rcl', 'rcr', 'rdtsc', 'rep', 'ret', 'retn', 'rol', 'ror', 'sal',
           'sar', 'sbb', 'scas', 'setb', 'setle', 'setnle', 'setnz', 'setz', 'shl', 'shld', 'shr', 'sidt', 'stc', 'std',
           'sti', 'stos', 'stosw', 'sub', 'test', 'wait', 'xchg', 'xor']

api_rgx = re.compile(r"extrn\s+(?:__imp_)?([^\s:]+)", flags=re.IGNORECASE)
call_rgx = re.compile(r"\scall\s+(?:ds:)(?:__imp_)?([^\s]+)", flags=re.IGNORECASE)

all_apis = []


# def label_benign_file():
#     with zipfile.ZipFile("good_samples.zip", "r") as zp:
#         zp.extractall("./data/samples")
#
#     files = os.listdir("data/samples/")
#     for file in files:
#         if len(file[:-6]) > 20:
#             benign['Id'].append(file[:-6])
#             benign['Class'].append(10)
#     df = pandas.DataFrame(benign)
#     df.to_csv('./data/trainLabels_benign.csv', mode='a', header=False, index=False)


def extract_binary_sizes(id: str) -> int:
    return os.path.getsize(id + ".bytes")


def extract_ngrams(ids: Sequence[str], seq_reader: SeqReader, n: int) -> Tuple[CountVectorizer, csr_matrix]:
    class Reader:
        def __init__(self, id: str):
            self.id = id

        def read(self):
            return seq_reader(self.id)

    seqs = [Reader(id) for id in ids]
    ngram_vct = CountVectorizer(ngram_range=(n, n), stop_words=None, token_pattern=r"(?u)\b[\w@?]{2,}\b", lowercase=False, input="file")
    ngrams = ngram_vct.fit_transform(seqs)
    return ngram_vct, ngrams


def extract_bytes_sequence(id: str) -> str:
    sequence_bytes = []
    for byte in ReadFile.bytes_reader(id):
        sequence_bytes.append(byte.lower())
    return " ".join(sequence_bytes)


def extract_opcode_sequence(id: str) -> str:
    sequence_opcodes = []
    for line in ReadFile.asm_lines(id):
        row = line.split()
        for opcode in opcodes:
            if opcode in row:
                sequence_opcodes.append(opcode)
                break
    return " ".join(sequence_opcodes)


def count_asm_opcode(id: str) -> np.ndarray:
    opcode_counter = np.zeros(len(opcodes))
    for line in ReadFile.asm_lines(id):
        parts = line.split()
        for opcode in opcodes:
            if opcode in parts:
                opcode_counter[opcodes.index(opcode)] += 1
                break
    return opcode_counter


def extract_syscall(id: str) -> None:
    asm = ReadFile.asm(id)
    apis = set(api_rgx.findall(asm))
    calls = call_rgx.findall(asm)
    syscalls = [i for i in calls if i in apis]
    list_syscalls = list(dict.fromkeys(syscalls))
    for syscall in list_syscalls:
        if syscall not in all_apis:
            all_apis.append(syscall)


def save_syscall() -> None:
    with open('Utils/syscalls.txt', 'w') as f:
        for api in all_apis:
            f.write(f"{api}\n")


def load_syscall() -> None:
    with open('Utils/syscalls.txt', 'r') as f:
        data = f.read()
        global all_apis
        all_apis = data.split("\n")


def check_syscall(id: str) -> np.ndarray:
    syscall_presence = np.zeros(len(all_apis))
    asm = ReadFile.asm(id)
    apis = set(api_rgx.findall(asm))
    calls = call_rgx.findall(asm)
    syscalls = [i for i in calls if i in apis]
    list_syscalls = list(dict.fromkeys(syscalls))
    for sys in list_syscalls:
        if sys in all_apis:
            syscall_presence[all_apis.index(sys)] += 1
    return syscall_presence


def extract_syscall_sequence(id: str) -> str:
    asm = ReadFile.asm(id)
    apis = set(api_rgx.findall(asm))
    calls = call_rgx.findall(asm)
    syscalls = [i for i in calls if i in apis]
    return " ".join(syscalls)


def extract_entropy(id: str) -> float:
    data = ReadFile.bytes_reader(id)
    possible = dict(((x, 0) for x in range(0, 256)))
    for byte in data:
        possible[int(byte, 16)] += 1

    data_len = len(data)
    entropy = 0.0

    for i in possible:
        if possible[i] == 0:
            continue

        p = float(possible[i] / data_len)
        entropy -= p * log(p, 2)

    return entropy


def extract_apis(id: str):
    apis = ReadFile.apis(id)
    for api in apis:
        if api not in all_apis:
            all_apis.append(api)


def save_apis() -> None:
    with open('Utils/apis.txt', 'w') as f:
        for api in all_apis:
            f.write(f"{api}\n")


def load_apis() -> None:
    with open('Utils/apis.txt', 'r') as f:
        data = f.read()
        global all_apis
        all_apis = data.split("\n")


def check_apis(id: str):
    apis_presence = np.zeros(len(all_apis))
    apis = ReadFile.apis(id)
    for api in apis:
        if api in all_apis:
            apis_presence[all_apis.index(api)] += 1
    return apis_presence